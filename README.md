## Ответы на вопросы

### 1. В чем отличие динамического массива от статического массива в языке C++?
**Статический массив** имеет фиксированный размер, который задаётся во время компиляции и не может быть изменён во время выполнения программы. Он обычно размещается в стеке.  
**Динамический массив** создаётся во время выполнения программы, его размер можно задать динамически. Он размещается в куче (heap) и требует явного управления памятью (выделения и освобождения).

### 2. Что такое указатель и зачем он используется при работе с динамической памятью?
**Указатель** — это переменная, которая хранит адрес другой переменной в памяти.  
При работе с динамической памятью указатель используется для хранения адреса области памяти, выделенной в куче (например, с помощью `new` или `malloc`), чтобы иметь доступ к этим данным и управлять ими.

### 3. Почему важно корректно освобождать память после использования динамических массивов?
Если не освобождать динамически выделенную память, возникает **утечка памяти**.  
Это приводит к избыточному потреблению оперативной памяти, снижению производительности и, в долгоживущих программах, к аварийному завершению из-за нехватки ресурсов.

### 4. В чём разница между последовательной и параллельной обработкой массива?
- **Последовательная обработка** выполняется одним потоком, элементы массива обрабатываются один за другим.
- **Параллельная обработка** распределяет обработку элементов массива между несколькими потоками, которые выполняются одновременно, что может значительно ускорить вычисления на многоядерных процессорах.

### 5. Что делает директива `#pragma omp parallel for`?
Директива `#pragma omp parallel for` автоматически распараллеливает цикл `for`, распределяя его итерации между несколькими потоками. Каждый поток выполняет свою часть итераций независимо от других.

### 6. Для чего используется механизм `reduction` в OpenMP?
Механизм `reduction` используется для безопасного объединения частичных результатов, вычисленных в разных потоках, в одно итоговое значение (например, сумма, произведение, минимум или максимум).

### 7. Почему при параллельном вычислении суммы необходимо использовать `reduction`, а не обычную переменную?
Если несколько потоков одновременно изменяют одну и ту же переменную, возникает **гонка данных (data race)**.  
`reduction` гарантирует, что каждый поток будет работать со своей локальной копией переменной, а затем все локальные значения будут корректно объединены в итоговый результат.

### 8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?
- Накладные расходы на создание и синхронизацию потоков  
- Слишком маленький объём вычислений (параллелизм не окупается)  
- Частые обращения к общей памяти и блокировки  
- Неравномерное распределение нагрузки между потоками  
- Ограничения пропускной способности памяти или кэша процессора


